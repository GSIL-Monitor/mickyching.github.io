#+TITLE: Linux Kernel Object
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil toc:nil
#+LATEX_CLASS: latex-doc

* kobject
相关文件：
- include/linux/kobject.h
- include/linux/kref.h
- lib/kobject.c
- lib/kobject_uevent.c

在使用的时候将kobject嵌入到其他数据结构中。
#+BEGIN_SRC cpp
  struct kobject {
      const char              *name;      // 目录名字
      struct list_head        entry;      // head: kset->list
      struct kobject          *parent;    // 父对象
      struct kset             *kset;      // 所属集合
      struct kobj_type        *ktype;     // 所属类型
      struct kernfs_node      *sd;        // 关联对象与sysfs
      struct kref             kref;       // 引用计数
  #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
      struct delayed_work     release;
  #endif
      unsigned int state_initialized:1;
      unsigned int state_in_sysfs:1;
      unsigned int state_add_uevent_sent:1;
      unsigned int state_remove_uevent_sent:1;
      unsigned int uevent_suppress:1;     // 禁止发送uevent
  };
#+END_SRC
kset和ktype容易混淆，ktype的概念类似于类型，因为包含析构函数，
而kset的概念类似于集合，将多个kobject放在一起。

** kref
#+BEGIN_SRC cpp
  struct kref {
      atomic_t refcount;
  };
  void kref_init(struct kref *kref);      // 初始化为1
  void kref_get(struct kref *kref);       // 增加计数
  int kref_put(struct kref *kref,         // 减少计数
               void (*release)(struct kref *kref));
  int __must_check kref_get_unless_zero(struct kref *kref);
#+END_SRC
当kref的计数减少到0的时候，就会有别的线程去释放对象，
此时如果去执行kref_get()就会出现竞态问题，
比较安全的做法是使用kref_get_unless_zero()。

** kobj_type
kobj_type相当于kobject的类型，包括了对sysfs操作的方法，
以及对kobject释放的析构函数。
#+BEGIN_SRC cpp
  struct kobj_type {
      void (*release)(struct kobject *kobj);
      const struct sysfs_ops *sysfs_ops;
      struct attribute **default_attrs;
      const struct kobj_ns_type_operations *
      (*child_ns_type)(struct kobject *kobj);
      const void *(*namespace)(struct kobject *kobj);
  };
  struct sysfs_ops {
      ssize_t (*show)(struct kobject *kobj, struct attribute *attr,
                      char *buf);
      ssize_t (*store)(struct kobject *kobj, struct attribute *attr,
                       const char *buf, size_t len);
  };
#+END_SRC
** kset
kset是一个kobject的集合，通过链表将集合内部的kobject串接起来。
并且kset本身也被设计为一个kobject对象，
因此也可以进一步将多个kset放到一个更大的kset中去。
#+BEGIN_SRC cpp
  struct kset {
      struct list_head list;              // node: kobj->list
      spinlock_t list_lock;
      struct kobject kobj;
      const struct kset_uevent_ops *uevent_ops;
  };

  struct kset_uevent_ops {
      int (* const filter)(struct kset *kset, struct kobject *kobj);
      const char *(* const name)(struct kset *kset,
                                 struct kobject *kobj);
      int (* const uevent)(struct kset *kset, struct kobject *kobj,
                           struct kobj_uevent_env *env);
  };
#+END_SRC
kset_uevent_ops简单说明：
- filter() 过滤不需要发送的uevent事件
- name() 用于获取subsystem的名字
- uevent() 一般负责添加更多的环境变量和执行dev->bus->uevent()

#+BEGIN_SRC cpp
  struct kobj_uevent_env {
      char *argv[3];
      char *envp[UEVENT_NUM_ENVP];
      int envp_idx;
      char buf[UEVENT_BUFFER_SIZE];
      int buflen;
  };
#+END_SRC
kobject_uevent_env用于保存环境变量。

kset相关操作如下
#+BEGIN_SRC cpp
  void kset_init(struct kset *kset);
  int __must_check kset_register(struct kset *kset);
  extern void kset_unregister(struct kset *kset);
  struct kset * __must_check
  kset_create_and_add(const char *name,
                      const struct kset_uevent_ops *uops,
                      struct kobject *parent);
  struct kset *to_kset(struct kobject *kobj);
  struct kset *kset_get(struct kset *kset);  // 调用kobject_get()
  void kset_put(struct kset *kset);          // 调用kobject_put()
  struct kobj_type *get_ktype(struct kobject *kobj);
  struct kobject *kset_find_obj(struct kset *kset, const char *name);

#+END_SRC
** kobject操作
#+BEGIN_SRC cpp
  // 该函数会分配保存名字所需的空间
  int kobject_set_name(struct kobject *kobj, const char *name, ...);
  const char *kobject_name(const struct kobject *kobj);
  void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
  // 会调用kobject_set_name()设置名字
  int kobject_add(struct kobject *kobj, struct kobject *parent,
                  const char *fmt, ...);
  int kobject_init_and_add(struct kobject *kobj,
                           struct kobj_type *ktype,
                           struct kobject *parent,
                           const char *fmt, ...);
  void kobject_del(struct kobject *kobj);
  struct kobject * __must_check kobject_create(void);
  struct kobject * __must_check
  kobject_create_and_add(const char *name, struct kobject *parent);
  int __must_check kobject_rename(struct kobject *kobj,
                                  const char *name);
  int __must_check kobject_move(struct kobject *kobj,
                                struct kobject *new_parent);
  struct kobject *kobject_get(struct kobject *kobj);
  void kobject_put(struct kobject *kobj);
#+END_SRC

kobject和uevent是紧密相连的，下面几个是和uevent相关的函数。
#+BEGIN_SRC cpp
  int kobject_uevent(struct kobject *kobj, enum kobject_action action);
  int kobject_uevent_env(struct kobject *kobj,
                         enum kobject_action action,
                         char *envp[]);
  // 将环境变量加入到env中
  int add_uevent_var(struct kobj_uevent_env *env,
                     const char *format, ...);
  // 将字符串转换为enum
  int kobject_action_type(const char *buf, size_t len,
                          enum kobject_action *type);
#+END_SRC

* uevent
提到kobject就不得不提到uevent，uevent是User space EVENT的缩写。
当用户插拔设备的时候，内核检测到设备插拔并发出插拔事件，
调用/proc/sys/kernel/hotplug中指定的用户空间应用对事件进行处理。

kobject代表一个sysfs目录，kobj_type代表类型，
提供对象的析构函数和对sysfs操作的接口。
kset代表子系统，包括了对子系统的操作集，如过滤，获取参数，填充环境变量等，
同一个kset内部的kobject共享一组uevent_ops。

以device_add为例，该函数的主要工作如下：
- 如果没有名字，设置设备的名字
- 设置其kobj的parent，kobj_add()添加kobject到parent下
- 创建设备sysfs目录下的文件
  - uevent
  - dev：有设备号才会创建
- device_add_class_symlinks()
  - subsystem：位于设备属性下，指向所属的子系统的符号链接。
  - device：位于设备属性下，有父亲且不是分区时才会创建，
    指向父设备的符号链接。
  - name：位于子系统属性下，指向设备属性，
    名字和设备名相同，如果是块设备就不会创建，
    因为已经在/sys/block下面创建了和设备名相同的符号链接。
- device_add_attrs()
  - dev->class->dev_groups
  - dev->type->groups
  - dev->groups
  - dev_attr_online
- bus_add_device()
  - device_add_attrs() 添加总线属性，不同于设备属性
  - bus->dev_groups
  - name：位于总线属性下，指向设备的符号链接
  - subsystem：位于设备属性下，指向总线的符号链接
- dpm_sysfs_add()
  - 动态PM相关sysfs文件
- device_pm_add()
  将设备添加到PM核心链表
- blocking_notifier_call_chain()
- =kobject_uevent(&dev->kobj, KOBJ_ADD);=
- bus_probe_device()
  为设备探测合适的驱动

该函数会通过kobject_uevent()发出uevent事件，甚至此时内核中可能没有对应的驱动，
但是用户空间的uevent_helper可以利用uevent信息来载入驱动，
载入驱动的时候也会执行一次设备和驱动间的匹配，从而实现动态载入驱动。

** kobject_uevent()
这个函数有必要梳理一下
#+BEGIN_SRC cpp
  int kobject_uevent(struct kobject *kobj, enum kobject_action action)
  {
      return kobject_uevent_env(kobj, action, NULL);
  }
#+END_SRC
这里假定所有函数都能成功执行，将其简化后如下所示。
#+BEGIN_SRC cpp
  int kobject_uevent_env(struct kobject *kobj,
                         enum kobject_action action,
                         char *envp_ext[])
  {
      struct kobj_uevent_env *env =
          kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
      // 利用字符串数组将enum转换为字符串
      const char *action_string = kobject_actions[action];
      struct kobject *top_kobj = ...;             // 必须找到kset
      struct kset *kset = top_kobj->kset;
      const struct kset_uevent_ops *uevent_ops = kset->uevent_ops;
      const char *subsystem;

      if (kobj->uevent_suppress)                  // 禁止发出
          return 0;
      if (uevent_ops && uevent_ops->filter)
          if (!uevent_ops->filter(kset, kobj))    // 被过滤
              return 0;

      if (uevent_ops && uevent_ops->name)
          subsystem = uevent_ops->name(kset, kobj);
      else
          subsystem = kobject_name(&kset->kobj);
      if (!subsystem)                             // 必须有子系统
          return 0;

      const char *devpath = kobject_get_path(kobj, GFP_KERNEL);
      add_uevent_var(env, "ACTION=%s", action_string);
      add_uevent_var(env, "DEVPATH=%s", devpath);
      add_uevent_var(env, "SUBSYSTEM=%s", subsystem);
      for (int i = 0; envp_ext && envp_ext[i]; i++) // 额外环境变量
              add_uevent_var(env, "%s", envp_ext[i]);
      if (uevent_ops && uevent_ops->uevent)       // kset操作
          uevent_ops->uevent(kset, kobj, env);

      if (action == KOBJ_ADD)
          kobj->state_add_uevent_sent = 1;
      else if (action == KOBJ_REMOVE)
          kobj->state_remove_uevent_sent = 1;

      mutex_lock(&uevent_sock_mutex);
      add_uevent_var(env, "SEQNUM=%llu",          // 序列号
                     (unsigned long long)++uevent_seqnum);

  #ifdef CONFIG_NET
      struct uevent_sock *ue_sk;
      list_for_each_entry(ue_sk, &uevent_sock_list, list) {
          struct sock *uevent_sock = ue_sk->sk;
          struct sk_buff *skb;
          char *scratch;
          size_t len;

          if (!netlink_has_listeners(uevent_sock, 1))
              continue;

          len = strlen(action_string) + strlen(devpath) + 2;
          skb = alloc_skb(len + env->buflen, GFP_KERNEL);

          scratch = skb_put(skb, len);
          sprintf(scratch, "%s@%s", action_string, devpath);

          for (i = 0; i < env->envp_idx; i++) {
              len = strlen(env->envp[i]) + 1;
              scratch = skb_put(skb, len);
              strcpy(scratch, env->envp[i]);
          }

          NETLINK_CB(skb).dst_group = 1;
          netlink_broadcast_filtered(uevent_sock, skb, 0, 1, GFP_KERNEL,
                                     kobj_bcast_filter, kobj);
      }
  #endif
      mutex_unlock(&uevent_sock_mutex);

  #ifdef CONFIG_UEVENT_HELPER
      if (uevent_helper[0] && !kobj_usermode_filter(kobj)) {
          struct subprocess_info *info;
          const char *path = "PATH=/sbin:/bin:/usr/sbin:/usr/bin"
          add_uevent_var(env, "HOME=/");
          add_uevent_var(env, path);
          init_uevent_argv(env, subsystem);
          info = call_usermodehelper_setup(env->argv[0], env->argv,
                                           env->envp, GFP_KERNEL, NULL,
                                           cleanup_uevent_env, env);
          call_usermodehelper_exec(info, UMH_NO_WAIT);
          env = NULL;     /* freed by cleanup_uevent_env */
      }
  #endif

   exit:
      kfree(devpath);
      kfree(env);
      return 0;
  }
#+END_SRC
从中可以看出，要使用netlink发出uevent，必须配置NET，
同样，要使用uevent_helper发出uevent，必须配置UEVENT_HELPER。
udev通过netlink监听，mdev则通过uevent_helper监听。
