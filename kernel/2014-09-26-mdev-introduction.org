#+TITLE: Mdev Introduction
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil toc:nil
#+LATEX_CLASS: latex-doc

* 基本概念

** 简介
mdev官方的叫法是mini udev in busybox，mdev实际只是busybox的一个符号链接。
执行mdev -s时会扫描/sys/class和/sys/block中的所有目录，
如果目录中有名为dev的文件，就从中读取设备号，并利用设备号在/dev下面创建节点。

启动时需要设置热插拔处理程序为mdev，当有热插拔事件产生时，内核调用mdev。
mdev通过环境变量ACTION和DEVPATH确定热插拔事件和影响目录，
接着查看目录下是否有dev文件，并利用其信息创建/dev节点。
如果ACTION为add，就会创建设备节点，如果为remove则删除设备节点。

mdev通过判断路径字符串第6个字符串是否为c来判断是字符设备还是块设备，
如path = "/sys/class/..."第6个字符为c，就被判断为字符设备，
path = "/sys/devices/..."会被判断为块设备。
所以写驱动只应当在/sys/class和/sys/block中创建设备属性文件。

** 编译配置
在busybox配置中加上mdev支持，此外如果要使用自动挂载功能，需要利用额外的脚本，
也就是可能还需要其他常用工具，如grep、mount、sh等。

另外在内核配置上面也要添加文件系统支持，包括语言支持，
既然要用到mdev也需要热插拔支持。

** 初始化脚本
mdev有两个用途，一个是初始化扫描，一个是动态更新。
mdev关键需要sysfs的支持，也就是必须要有/sys目录。
在扫描的时候mdev会扫描/sys/class/.../dev文件，dev文件是包含设备号的文件，
其所在的目录一般就对应为相关设备的属性目录。
至于动态更新，需要在内核支持热插拔，当发现有插拔事件的时候，内核会发出通知，
并调用hotplug程序，一般PC上是udev，嵌入式平台是mdev，
通过写入如下文件来指定热插拔程序为mdev。
#+BEGIN_SRC sh
  echo /bin/mdev > /proc/sys/kernel/hotplug
#+END_SRC
内核在调用热插拔处理程序的时候会传递一系列环境变量，在写mdev的配置文件时，
也可以利用这里环境变量。

在嵌入式平台，要支持mdev，首先要做的是配置系统启动设置，包括挂载必要的文件系统，
以及设置hotplug程序。
如下是一段典型的初始化脚本。
#+BEGIN_SRC sh
  mount -t proc proc /proc                # 用于设定hotplug的文件系统
  mount -t sysfs sysfs /sys               # 用于mdev扫描的文件系统
  mount -t tmpfs -o size=64k,mode=0755 tmpfs /media # 用于挂载磁盘设备
  mount -t tmpfs -o size=64k,mode=0755 tmpfs /dev   # 用于创建设备节点
  echo /bin/mdev > /proc/sys/kernel/hotplug         # 设定hotplug程序
  mdev -s                                           # 启动扫描
#+END_SRC

如果文件系统在flash外运行，还需要先创建/dev/pts节点，再执行mdev的初始化脚本。
#+BEGIN_SRC sh
  mkdir /dev/pts
  mount -t devpts devpts /dev/pts
#+END_SRC

也可以不通过procfs来设置hotplug程序，通过如下命令实现。
#+BEGIN_SRC sh
  sysctl -w kernel.hotplug=/sbin/mdev
#+END_SRC

** 配置文件
配置文件位于/etc/mdev.conf，语法分为四个部分。
第1部分是匹配规则，也就是匹配到对应的设备，
第2部分是用户ID和组ID，第3部分是权限，最后一部分是命令。

文件格式如下：
#+BEGIN_SRC sh
  [-][envmatch]<device_regex>        <uid>:<gid> <permissions> [cmd]
  [-][envmatch]@<maj[,min1[-min2]]>  <uid>:<gid> <permissions> [cmd]
  [-][envmatch]$envvar=<regex>       <uid>:<gid> <permissions> [cmd]
  [-][envmatch]subsystem/regex       <uid>:<gid> <permissions> [cmd]
#+END_SRC
- - ::
  不要在匹配到该行就停止搜索
- uid/gid ::
  可以是数字也可以是名字

其中"$envvar=<regex>"在热插拔设备需要模块载入时非常有用，因为此时没有驱动，
也就不会存在/sys/class/.../dev文件，但是$MODALIAS会设置，表示需要的模块。
可以使用如下规则，在需要模块的时候自动导入模块。
#+BEGIN_SRC sh
  $MODALIAS=.* 0:0 660 @modprobe "$MODALIAS"
#+END_SRC
当/sys/class/.../dev出现的时候又会产生另一个热插拔事件给mdev处理。

命令分两种，一种是控制设备节点生成路径，一种是执行外部shell命令，
两者可以同时使用。

*** 路径控制命令

路径控制的命令格式为
#+BEGIN_SRC sh
  [=>!]path
#+END_SRC
- = ::
  仅仅移动路径，如果要移动到一个目录下面，在path后面一定要有一个斜杠"/"。
- > ::
  移动路径，并在dev下面创建一个符号链接
- ! ::
  禁止创建设备节点
- %1..%9 ::
  如果用了正则表达式，那么用该符号引用匹配到的表达式，
  一个小括号作为一组，依次用%1..%9表示。

简单示例如下。
#+BEGIN_SRC sh
  hda 0:0 660 =drives/                    # 将hda移动到drives目录
  hdb 0:0 660 =cdrom                      # 将hdb命名为cdrom
  tty[a-z] 0:0 660 !                      # 利用!阻止创建设备节点
  ([hs]d[a-z])            root:disk       660 >disk/%1/0
  ([hs]d[a-z])([0-9]+)    root:disk       660 >disk/%1/%2
  mmcblk([0-9]+)          root:disk       660 >disk/mmc/%1/0
  mmcblk([0-9]+)p([0-9]+) root:disk       660 >disk/mmc/%1/%2
  (tun|tap)               root:network    660 >net/%1
#+END_SRC

*** 外部命令
要执行外部命令，需要在特殊符号后面加上要执行的命令，特殊符号用于指示执行的时间。
命令是通过system系统调用执行的，因此要确保有安装sh。
命令会获取到两个环境变量，$SUBSYSTEM和$MDEV，$SUBSYSTEM表示设备所在的子系统，
$MDEV为设备名字，如hda。
#+BEGIN_SRC sh
  [@|$|*]<command>
#+END_SRC
- @ :: 在创建设备节点之后运行
- $ :: 在移除设备节点之前运行
- * :: 在创建设备节点之后，移除设备节点之前运行

hotplug将stdout、stderr和stdin连接到/dev/null，
因此在执行mdev的时候是看不到输出的。

配置举例：
#+BEGIN_VERSE
- [[file:src/mdev/eg0-mdev.conf][boss mdev.conf]]  [[https://github.com/slashbeast/mdev-like-a-boss][@github]]
- [[file:src/mdev/eg1-mdev.conf][snafu mdev.conf]] [[http://www.snafu.priv.at/interests/debian/mdev.html][@snafu]]
- [[http://cross-lfs.org/view/clfs-embedded/arm/bootscripts/mdev.html][clfs mdev.conf]]
#+END_VERSE

** 固件
所有的firmware需要放到/lib/firmware，运行的时候，内核调用mdev，并传递文件名，
文件名是在源代码中直接指定的。

** 顺序插拔
内核并不会将热插拔事件顺序化，仅仅增加SEQNUM环境变量的值，
mdev可能会按照不同的顺序处理热插拔事件。

如果发现了/dev/mdev.seq那么就会和SEQNUM比较，有两秒钟的比较时间，
如果不相同，会按照通常方式运行，并写入SEQNUM + 1。
想要激活这个特性非常简单，执行如下命令。
#+BEGIN_SRC sh
  echo > /dev/mdev.seq
#+END_SRC
就会会插入一个换行符，但是mdev足够聪明，它不会在这种情况下去等待两秒钟。

** 热插拔配置
插拔自动挂载需要先写一个脚本，假定脚本为[[file:src/mdev/automounter.sh][/lib/mdev/automounter.sh]]，
并且要确保文件有可执行权限，内容如下。
#+INCLUDE: src/mdev/automounter.sh src sh

接着根据automounter.sh配置mdev.conf文件。
#+BEGIN_SRC sh
  sd[a-z]           0:0     660
  mmcblk[0-9]       0:0     660
  sd[a-z][0-9]      0:0     660 */lib/mdev/automounter.sh
  mmcblk[0-9]p[0-9] 0:0     660 */lib/mdev/automounter.sh
#+END_SRC

此外还要修改一下/media目录文件系统类型，因为打算用它创建动态挂在点，
所以最好将它用tmpfs从Flash移动到RAM中。
可以通过上面提到的方法，写入到启动脚本，可以编辑/etc/fstab。
#+BEGIN_SRC sh
  tmpfs         /media  tmpfs   defaults        0       0
#+END_SRC

如果存在/dev/mdev.log文件，调试信息将自动添加到该文件。

* 参考资料
- [[http://git.busybox.net/busybox/tree/docs/mdev.txt][mdev官方文档]]
- [[http://git.busybox.net/busybox/tree/util-linux/mdev.c][mdev源代码]]
