---
title: Go语言笔记
author: 敬叶
categories: language
tags: golang
---
<div id="table-of-contents"><h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline14">语法要点</a>
<ul>
<li><a href="#orgheadline2">语言特性</a>
<ul>
<li><a href="#orgheadline1">语言特性</a></li>
</ul>
</li>
<li><a href="#orgheadline5">数据类型</a>
<ul>
<li><a href="#orgheadline3">基本类型</a></li>
<li><a href="#orgheadline4">复合类型</a></li>
</ul>
</li>
<li><a href="#orgheadline9">过程语法</a>
<ul>
<li><a href="#orgheadline6">表达式</a></li>
<li><a href="#orgheadline7">语句</a></li>
<li><a href="#orgheadline8">函数</a></li>
</ul>
</li>
<li><a href="#orgheadline13">对象语法</a>
<ul>
<li><a href="#orgheadline10">数据</a></li>
<li><a href="#orgheadline11">方法</a></li>
<li><a href="#orgheadline12">接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline25">编程实践</a>
<ul>
<li><a href="#orgheadline16">标准库</a>
<ul>
<li><a href="#orgheadline15">常用包库</a></li>
</ul>
</li>
<li><a href="#orgheadline20">并发编程</a>
<ul>
<li><a href="#orgheadline17">并发编程</a></li>
<li><a href="#orgheadline18">过度并发</a></li>
<li><a href="#orgheadline19">睡眠定时</a></li>
</ul>
</li>
<li><a href="#orgheadline24">项目管理</a>
<ul>
<li><a href="#orgheadline21">基本配置</a></li>
<li><a href="#orgheadline22">依赖管理</a></li>
<li><a href="#orgheadline23">质量管理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline26">参考资料</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">语法要点</h2>
<div class="outline-text-2" id="text-orgheadline14">
</div><div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">语言特性</h3>
<div class="outline-text-3" id="text-orgheadline2">
</div><div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1">语言特性</h4>
<div class="outline-text-4" id="text-orgheadline1">
<!--abstract-begin-->

<p>
从Go语言的演化来看，可以分为三条主线：从C语言继承了基本数据类型、表达式语法、指针与函数。从Pascal-Oberon-2继承了包管理和面向对象声明语法。从CSP中继承管道通信。
</p>

<p>
Go语言有很多自带功能，这些功能基本都是以提高开发效率为目的：
</p>
<ul class="org-ul">
<li>严格的代码规范：大小写、括号位置、缩进等</li>
<li>多返回值支持，统一的错误处理形式</li>
<li>类型安全（静态类型）</li>
<li>常用数据类型：map/slice</li>
<li>匿名函数</li>
<li>闭包</li>
<li>垃圾回收</li>
<li>包管理系统</li>
<li>只读UTF-8字符串</li>
<li>系统调用接口</li>
</ul>

<!--abstract-end-->

<p>
相比C++又缺失了很多功能，缺少的这些功能要么是影响开发效率，要么是影响编译效率：
</p>
<ul class="org-ul">
<li>没有隐式类型转换：需要编写丑陋的强制转换</li>
<li>不支持静态变量：闭包</li>
<li>没有指针算术：无法实现</li>
<li>没有构造/析构函数：需要编写普通函数来构造对象，垃圾回收自带析构功能</li>
<li>没有运算符重载：函数作为一等公民</li>
<li>没有默认参数：强制传入参数</li>
<li>没有继承：匿名成员实现继承效果</li>
<li>没有多态：非侵入性接口</li>
<li>没有泛型：这和没有默认参数一样，只能手动加入代码</li>
<li>没有异常：用panic/recover处理运行时异常</li>
<li>没有宏：函数作为一等公民</li>
<li>没有函数修饰：结构体加成员函数</li>
<li>没有线程局部存储：信道通信实现共享</li>
<li>不支持动态链接库：无法实现</li>
</ul>

<p>
另外Go语言的注释并不总是注释，例如导入C包时，注释可以用来写C语言代码，这就导致注释不能随意清理。
</p>

<p>
保留关键字
</p>
<pre class="example">
keywords: break      default       func     interface   select
          case       defer         go       map         struct
          chan       else          goto     package     switch
          const      fallthrough   if       range       type
          continue   for           import   return      var
constant: true false iota nil
type:     int int8-64 uint8-64 float32-64 complex64-128
          bool byte rune uintptr string error
function: make len cap new append copy close delete complex real imag
          panic recover
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">数据类型</h3>
<div class="outline-text-3" id="text-orgheadline5">
</div><div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">基本类型</h4>
<div class="outline-text-4" id="text-orgheadline3">
<p>
变量声明时变量名在类型名之前，支持多变量定义及赋值，多变量赋值的要点是先计算后赋值。简短声明需要注意作用域问题，在内嵌块中用简短声明同名变量时会产生新的变量，这种特性有可能产生很难调试的问题。
</p>

<p>
整数类型<code>int</code>的长度由CPU而定，另一个和机器相关的类型是<code>uintptr</code>。字符类型<code>rune</code>等价于<code>uint32</code>，二者可以互换使用，同样<code>byte</code>也是<code>int8</code>的等价类型。
</p>

<p>
Go语言不支持隐式类型转换，即便是整型向布尔转换也不行。对于无类型常量，编译器提供至少32字节的运算精度，这个精度大于Go语言中整型量。将无类型常量复制给变量时，可能会发生隐式转换，因为无类型常量也可以认为有一个最佳匹配类型。
</p>

<p>
字符串被设计为不可变对象，也就是不能修改字符，字符串末尾没有空字符。字符串支持切片操作。用<code>``</code>定义的字符串不对转义字符转义，支持跨行，这种形式称作原生字符串。要修改字符串可以转换为<code>[]rune</code>或<code>[]byte</code>数组再修改，转换会复制内存。遍历字符串用<code>range</code>完成，要按字节遍历可以直接用下标访问。用<code>len()</code>对字符串计算长度得到的是字符串的字节数。
</p>

<p>
数组被设计为数值类型，赋值和参数传递会复制整个数组。指针数组<code>[n]*T</code>和数组指针<code>*[n]T</code>表达上看星号位置。因为数组是值传递，所以实际上很少会用到，大多情况都使用切片。
</p>

<p>
指针不支持算术运算，但支持解引用和成员操作符，成员操作符统一用点操作，箭头不再具有取成员的功能。比较特别的是返回局部变量的指针是安全的，这种情况编译器会做逃逸分析并视情况选择是否在堆上分配。
</p>

<p>
函数<code>new()</code>用于创建对象，并返回一个指针。由于返回自动变量的指针是安全的，所以<code>new()</code>本身可有可无，好处是可以让代码更简洁一点。
</p>

<p>
选择在栈上分配还是在堆上分配取决于编译器的逃逸分析结果：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">var_on_heap</span>() *<span style="color: #800;">int</span> {               <span style="color: #666;">// </span><span style="color: #666;">compiler alloc on heap</span>
        <span style="color: #800;">var</span> x int
        x = 1
        <span style="color: #800;">return</span> &amp;x
}

<span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">var_on_stack</span>() {                   <span style="color: #666;">// </span><span style="color: #666;">compiler alloc on stack(or heap)</span>
        y := <span style="color: #800;">new</span>(<span style="color: #800;">int</span>)
        *y = 1
}
</pre>
</div>

<p>
关键字<code>type</code>用于定义新类型，和C语言的<code>typedef</code>相似。但是需要强调即便是用同一个类型衍生的两个类型，也表示不同的类型，因此相互之间不能直接比较和运算。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">复合类型</h4>
<div class="outline-text-4" id="text-orgheadline4">
<p>
切片类型和数组在形式上的区别是切片没有指定长度，并且切片不能像数组一样直接进行比较。对数组执行切片操作，就能得到一个切片类型，为了节省内存，切片之后并不会复制内存。
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">struct</span> slice
{
        byte*    array;      <span style="color: #666;">// </span><span style="color: #666;">actual data</span>
        uintgo   len;        <span style="color: #666;">// </span><span style="color: #666;">number of elements</span>
        uintgo   cap;        <span style="color: #666;">// </span><span style="color: #666;">allocated number of elements</span>
};
array := [...]<span style="color: #800;">int</span>{0, 1, 2, 3, 4, 5, 6}
slice := array[1:4:5]                    <span style="color: #666;">// </span><span style="color: #666;">[beg:end:cap]</span>
</pre>
</div>

<dl class="org-dl">
<dt>append(s, x&#x2026;)</dt><dd>用于向slice尾部添加数据，超出cap就会重新分配并复制。</dd>
<dt>copy(dst, src)</dt><dd>复制以长度小的为准，复制本身不会分配内存</dd>
</dl>

<p>
对切片是否为空的测试应利用长度来判断，而不是直接和<code>nil</code>比较。因为存在长度为0但是本身却不为<code>nil</code>的情况。
</p>

<p>
映射是基于哈希表的引用类型，支持index、delete操作。索引取回的是复制品，对成员修改并不会作用到映射中的数据，只能是用一个新的值去替换。迭代时可以删除，但是不要新增。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">过程语法</h3>
<div class="outline-text-3" id="text-orgheadline9">
</div><div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">表达式</h4>
<div class="outline-text-4" id="text-orgheadline6">
<p>
Go语言在运算符优先级上也做了较大简化，如下所示，一共只有五级。
</p>
<pre class="example">
%      *      /      &lt;&lt;       &gt;&gt;     &amp;(AND)   &amp;^
+      -      |(OR)  ^(NOT, XOR)
==     !=     &lt;      &lt;=       &gt;      &gt;=
&amp;&amp;
||
</pre>
<p>
对于<code>&amp;^</code>更倾向于认为他们是两个操作的叠加，将<code>^</code>解释为单目按位取反操作，可以认为<code>^a = 0xF...F ^ a</code>。逻辑操作<code>&amp;&amp;</code>和<code>||</code>可以更形象比作逻辑乘法和逻辑加法。
</p>

<p>
除法运算若两个参数都是整数，则执行整数除法，否则执行浮点数除法，乘法运算原理相同。取模的原则是：结果的符号和被取模的数符号一致。
</p>

<p>
算术运算溢出时，高位被丢弃，有符号类型情况比较复杂，如对于<code>int8</code>执行<code>127 + 1</code>得到的结果将是<code>-128</code>。
</p>

<p>
不支持运算符重载，另外注意<code>++</code>和<code>--</code>是语句，而不是表达式。按位取反运算采用<code>^</code>算符，而不是C语言中的<code>~</code>算符。
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7">语句</h4>
<div class="outline-text-4" id="text-orgheadline7">
<p>
对分支语句添加了初始化语句支持，没有<code>?:</code>操作符。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">if</span> init; condition {
        statements
} <span style="color: #800;">else</span> <span style="color: #800;">if</span> condition {
        statements
} <span style="color: #800;">else</span> {
        statements
}

<span style="color: #800;">switch</span> expr {
<span style="color: #800;">case</span> value:
        statements
<span style="color: #800;">default</span>:
        statements
}

<span style="color: #800;">switch</span> {
<span style="color: #800;">case</span> condition:
        statements
<span style="color: #800;">default</span>:
        statements
}
</pre>
</div>

<p>
迭代语句range所返回的对象是复制对象，而不是原生对象，当使用引用类型时，底层数据不会被复制。
</p>

<p>
Go语言对for语句做了大量重载工作，将原来属于while语句的写法都移植到for语句中了。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">for</span> idx, item := <span style="color: #800;">range</span> seqs {           <span style="color: #666;">// </span><span style="color: #666;">like for in Python</span>
        statements
}

<span style="color: #800;">for</span> init; condition; post {             <span style="color: #666;">// </span><span style="color: #666;">like for in C++</span>
        statements
}

<span style="color: #800;">for</span> condition {                         <span style="color: #666;">// </span><span style="color: #666;">like while</span>
        statements
}

<span style="color: #800;">for</span> {                                   <span style="color: #666;">// </span><span style="color: #666;">like while(1)</span>
        statements
}
</pre>
</div>

<p>
迭代语句range对不同的序列返回不同：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #048; font-weight: bold;">string</span>       (i, s[i])
array/<span style="color: #048; font-weight: bold;">slice</span>  (i, a[i])
<span style="color: #800;">map</span>          (key, m[key])
channel      e
</pre>
</div>

<p>
分支语句switch不再需要写break了，要继续则要显示注明fallthrough。省略元素判别之后就可以当作<code>if...else if...</code>语句。
</p>

<p>
跳转语句break/continue支持带标签形式。
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8">函数</h4>
<div class="outline-text-4" id="text-orgheadline8">
<p>
函数不支持嵌套、重载和默认参数。但支持匿名函数和闭包。
</p>

<p>
变参本质上是切片，只能放于最后。使用切片作为变参时，需要展开为<code>s...</code>。
</p>

<p>
多返回值只能用多变量接，不能用容器对象接收，但是可以直接传递给函数参数。对于命名返回参数，如果被局部变量遮蔽，就需要显式返回。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">add</span>(x, y <span style="color: #800;">int</span>) (z <span style="color: #800;">int</span>) {
        {
                <span style="color: #800;">var</span> z = x + y
                <span style="color: #800;">return</span>                  <span style="color: #666;">// </span><span style="color: #666;">ERROR: z is shadowed during return</span>
                <span style="color: #800;">return</span> z
        }
}
</pre>
</div>

<p>
命名返回参数支持<code>defer</code>延迟通过闭包修改。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">add</span>(x, y <span style="color: #800;">int</span>) (z <span style="color: #800;">int</span>) {
        <span style="color: #800;">defer</span> <span style="color: #800;">func</span>() {
                z += 100
        }()
        z = x + y
        <span style="color: #800;">return</span>
}
</pre>
</div>

<p>
匿名函数可以在channel中传送。
</p>
<div class="org-src-container">

<pre class="src src-go">fc := <span style="color: #800;">make</span>(<span style="color: #800;">chan</span> <span style="color: #800;">func</span>() <span style="color: #800;">string</span>, 2)
fc &lt;- <span style="color: #800;">func</span>() <span style="color: #800;">string</span> { <span style="color: #800;">return</span> <span style="color: #800;">"Hello, World!"</span> }
<span style="color: #800;">println</span>((&lt;-fc)())
</pre>
</div>

<p>
延迟调用主要负责释放资源和错误处理。不要滥用defer功能，滥用defer功能容易引发性能问题。多个defer采用FILO顺序执行。
</p>

<p>
用panic抛出错误，用recover修复错误。对recover的调用有非常严格的限制，必须在<code>defer</code>函数内直接调用才会终止错误，其它地方调用仅返回nil。
</p>

<p>
当匿名函数需要递归调用时，需要先声明变量：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">var</span> visitAll <span style="color: #800;">func</span>(items []<span style="color: #800;">string</span>)
visitAll = <span style="color: #800;">func</span>(items []<span style="color: #800;">string</span>) {
        <span style="color: #048; font-weight: bold;">visitAll</span>(m[item])               <span style="color: #666;">// </span><span style="color: #666;">ok</span>
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-go">visitAll := <span style="color: #800;">func</span>(items []<span style="color: #800;">string</span>) {
        <span style="color: #048; font-weight: bold;">visitAll</span>(m[item])               <span style="color: #666;">// </span><span style="color: #666;">compile error: undefined: visitAll</span>
}
</pre>
</div>

<p>
在循环中使用匿名函数时要格外小心，下面的问题在于循环变量的作用域，当运行匿名函数时循环已经结束，此时所有线程都是针对最后一个值进行操作：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">var</span> rmdirs []<span style="color: #800;">func</span>()
<span style="color: #800;">for</span> _, dir := <span style="color: #800;">range</span> <span style="color: #048; font-weight: bold;">tempDirs</span>() {
        os.<span style="color: #048; font-weight: bold;">MkdirAll</span>(dir, 0755)          <span style="color: #666;">// </span><span style="color: #666;">ok</span>
        rmdirs = <span style="color: #800;">append</span>(rmdirs, <span style="color: #800;">func</span>() {
                os.<span style="color: #048; font-weight: bold;">RemoveAll</span>(dir)       <span style="color: #666;">// </span><span style="color: #666;">NOTE: incorrect!</span>
        })
}
<span style="color: #800;">for</span> _, rmdir := <span style="color: #800;">range</span> rmdirs {
    <span style="color: #048; font-weight: bold;">rmdir</span>()
}
</pre>
</div>
<p>
正确的操作是：在循环内部声明一个变量，或者定义带参数的匿名函数。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">对象语法</h3>
<div class="outline-text-3" id="text-orgheadline13">
</div><div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">数据</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
结构体定义用如下格式：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">type</span> <span style="color: #800;">Newtype</span> <span style="color: #800;">struct</span> {
        member          Int;
}
<span style="color: #800;">var</span> temp Newtype;                       <span style="color: #666;">// </span><span style="color: #666;">define variable</span>
</pre>
</div>

<p>
结构体顺序初始化必须包括全部字段，结构体支持匿名字段，匿名成员的真正用途是提供对基类方法调用的简短写法，因此不要滥用匿名成员。
</p>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">方法</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
方法只不过多了一个接收对象，可以理解为函数的第一个隐式参数。对于方法的查找，要注意不支持多级指针查找，也就是说想通过多级指针调用方法，就必须显式声明接收对象为多级指针。
</p>

<p>
通过匿名字段可以获得和继承类似的复用能力，利用编译器查找次序可以实现重写。
</p>

<p>
对方法调用有两种形式：
</p>
<div class="org-src-container">

<pre class="src src-go">instance.<span style="color: #048; font-weight: bold;">method</span>(args...)                <span style="color: #666;">// </span><span style="color: #666;">method value</span>
&lt;<span style="color: #800;">type</span>&gt;.<span style="color: #800;">func</span>(instance, args...)          <span style="color: #666;">// </span><span style="color: #666;">method expression</span>
</pre>
</div>

<p>
method value会复制接收对象，下面的代码中，如果<code>Print()</code>的接收对象是指针，将打印修改后的值，如果<code>Print()</code>的接收对象是值，将打印修改前的值。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">main</span>() {
        u := <span style="color: #800;">User</span>{1, <span style="color: #800;">"Tom"</span>}
        uprint := u.Print               <span style="color: #666;">// </span><span style="color: #666;">copy receiver</span>
        u.id, u.name = 2, <span style="color: #800;">"Jack"</span>
        <span style="color: #048; font-weight: bold;">uprint</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12">接口</h4>
<div class="outline-text-4" id="text-orgheadline12">
<p>
接口本质上就是方法的集合，只要一个类实现了接口中的所有函数，那么就是提供了该接口。如下所示，所有动物都可以定一个Speak()接口。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">type</span> <span style="color: #800;">Animal</span> <span style="color: #800;">interface</span> {
        <span style="color: #048; font-weight: bold;">Speak</span>() string
}
<span style="color: #800;">func</span> (c <span style="color: #800;">Cat</span>) <span style="color: #048; font-weight: bold;">Speak</span>() <span style="color: #800;">string</span> {
        <span style="color: #800;">return</span> <span style="color: #800;">"Meow!"</span>
}
<span style="color: #800;">func</span> (j <span style="color: #800;">JavaProgrammer</span>) <span style="color: #048; font-weight: bold;">Speak</span>() <span style="color: #800;">string</span> {
        <span style="color: #800;">return</span> <span style="color: #800;">"Design patterns!"</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-2">
<h2 id="orgheadline25">编程实践</h2>
<div class="outline-text-2" id="text-orgheadline25">
</div><div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">标准库</h3>
<div class="outline-text-3" id="text-orgheadline16">
</div><div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">常用包库</h4>
<div class="outline-text-4" id="text-orgheadline15">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">包名</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bufio</td>
<td class="org-left">有缓冲的I/O操作</td>
</tr>

<tr>
<td class="org-left">bytes</td>
<td class="org-left">对[]byte操作，类似strings包</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">类似IO缓冲，也实现了Reader/Buffer基于[]byte的缓冲</td>
</tr>

<tr>
<td class="org-left">builtin</td>
<td class="org-left">内建标识符文档</td>
</tr>

<tr>
<td class="org-left">database.sql</td>
<td class="org-left">提供SQL数据库接口</td>
</tr>

<tr>
<td class="org-left">encoding</td>
<td class="org-left">字节和文本转换接口，包括多个子包</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">常用子包：base64 binary csv json</td>
</tr>

<tr>
<td class="org-left">errors</td>
<td class="org-left">实现了创建错误值的函数</td>
</tr>

<tr>
<td class="org-left">expvar</td>
<td class="org-left">提供公共变量的标准接口，读写操作都是原子级的</td>
</tr>

<tr>
<td class="org-left">flag</td>
<td class="org-left">命令行标签解析</td>
</tr>

<tr>
<td class="org-left">fmt</td>
<td class="org-left">实现了类似C语言printf和scanf的格式化I/O</td>
</tr>

<tr>
<td class="org-left">io</td>
<td class="org-left">对I/O原语的基本接口</td>
</tr>

<tr>
<td class="org-left">io.ioutil</td>
<td class="org-left">实现I/O常用辅助函数</td>
</tr>

<tr>
<td class="org-left">log</td>
<td class="org-left">简单日志服务</td>
</tr>

<tr>
<td class="org-left">log.syslog</td>
<td class="org-left">提供一个简单的系统日志服务的接口</td>
</tr>

<tr>
<td class="org-left">math.rand</td>
<td class="org-left">伪随机数生成器</td>
</tr>

<tr>
<td class="org-left">net</td>
<td class="org-left">提供了可移植的网络I/O接口</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">包括TCP/IP、UDP、域名解析和Unix-socket</td>
</tr>

<tr>
<td class="org-left">net.http</td>
<td class="org-left">HTTP客户端和服务端的实现</td>
</tr>

<tr>
<td class="org-left">net.http.pprof</td>
<td class="org-left">HTTP服务返回runtime的统计数据</td>
</tr>

<tr>
<td class="org-left">os</td>
<td class="org-left">操作系统函数的不依赖平台的接口</td>
</tr>

<tr>
<td class="org-left">os.exec</td>
<td class="org-left">执行外部命令</td>
</tr>

<tr>
<td class="org-left">path</td>
<td class="org-left">实现了对斜杠分隔的路径的实用操作函数</td>
</tr>

<tr>
<td class="org-left">path.filepath</td>
<td class="org-left">兼容各操作系统的文件路径的实用操作函数</td>
</tr>

<tr>
<td class="org-left">reflect</td>
<td class="org-left">运行时反射</td>
</tr>

<tr>
<td class="org-left">regexp</td>
<td class="org-left">正则表达式搜索</td>
</tr>

<tr>
<td class="org-left">sort</td>
<td class="org-left">为切片及用户定义的集合的排序操作提供了原语</td>
</tr>

<tr>
<td class="org-left">strconv</td>
<td class="org-left">基本数据类型和其字符串表示的相互转换</td>
</tr>

<tr>
<td class="org-left">strings</td>
<td class="org-left">用于操作字符的简单函数</td>
</tr>

<tr>
<td class="org-left">sync</td>
<td class="org-left">提供了互斥锁这类的基本的同步原语</td>
</tr>

<tr>
<td class="org-left">sync.atomic</td>
<td class="org-left">提供了底层的原子性内存原语</td>
</tr>

<tr>
<td class="org-left">time</td>
<td class="org-left">时间的显示和测量用的函数</td>
</tr>

<tr>
<td class="org-left">unsafe</td>
<td class="org-left">包含有关于Go程序类型安全的所有操作</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">并发编程</h3>
<div class="outline-text-3" id="text-orgheadline20">
</div><div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">并发编程</h4>
<div class="outline-text-4" id="text-orgheadline17">
<p>
在语言层面提供了<code>goroutine</code>，单个进程可以执行成千上万的并发任务，提供<code>channel</code>来通讯。
<code>channel</code>在内部实现提供了同步机制，能确保并发安全，默认采用同步模式，接收和发送必须配对，否则一直阻塞。
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">main</span>() {
        data := <span style="color: #800;">make</span>(<span style="color: #800;">chan</span> <span style="color: #800;">int</span>)           <span style="color: #666;">// </span><span style="color: #666;">&#25968;&#25454;&#20132;&#25442;&#38431;&#21015;</span>
        exit := <span style="color: #800;">make</span>(<span style="color: #800;">chan</span> <span style="color: #800;">bool</span>)          <span style="color: #666;">// </span><span style="color: #666;">&#36864;&#20986;&#36890;&#30693;</span>
        <span style="color: #800;">go</span> <span style="color: #800;">func</span>() {
                <span style="color: #800;">for</span> d := <span style="color: #800;">range</span> data {    <span style="color: #666;">// </span><span style="color: #666;">&#20174;&#38431;&#21015;&#36845;&#20195;&#25509;&#25910;&#25968;&#25454;&#65292;&#30452;&#21040; close</span>
                        fmt.<span style="color: #048; font-weight: bold;">Println</span>(d)
                }
                fmt.<span style="color: #048; font-weight: bold;">Println</span>(<span style="color: #800;">"recv over."</span>)
                exit &lt;- <span style="color: #800;">true</span>             <span style="color: #666;">// </span><span style="color: #666;">&#21457;&#20986;&#36864;&#20986;&#36890;&#30693;</span>
        }()
        data &lt;- 1                        <span style="color: #666;">// </span><span style="color: #666;">&#21457;&#36865;&#25968;&#25454;</span>
        data &lt;- 2
        data &lt;- 3
        <span style="color: #800;">close</span>(data)                      <span style="color: #666;">// </span><span style="color: #666;">&#20851;&#38381;&#38431;&#21015;</span>
        fmt.<span style="color: #048; font-weight: bold;">Println</span>(<span style="color: #800;">"send over."</span>)
        &lt;-exit                           <span style="color: #666;">// </span><span style="color: #666;">&#31561;&#24453;&#36864;&#20986;&#36890;&#30693;</span>
}
</pre>
</div>

<p>
异步方式通过缓冲区来决定是否阻塞，利用缓冲区来提供效率，另一方面应该考虑指针来规避大数据复制。内置函数cap()可以获取缓冲大小，len()可以获取有效元素个数，在并发程序len()的值会不准确。
</p>

<p>
对已关闭的channel发送数据会引发panic，从已关闭channel接收数据会返回零值，所以关闭应该由生产方控制，接受方也可以通过第二个返回值判断信道是否被关闭，或者用range迭代来自动退出关闭信道。
</p>

<p>
对于nil channel，收发都会阻塞。
</p>

<div class="org-src-container">

<pre class="src src-go">c := <span style="color: #800;">make</span>(<span style="color: #800;">chan</span> <span style="color: #800;">int</span>, 3)
<span style="color: #800;">var</span> send <span style="color: #800;">chan</span>&lt;- <span style="color: #800;">int</span> = c                 <span style="color: #666;">// </span><span style="color: #666;">send only</span>
<span style="color: #800;">var</span> recv &lt;-<span style="color: #800;">chan</span> <span style="color: #800;">int</span> = c                 <span style="color: #666;">// </span><span style="color: #666;">recv only</span>
send &lt;- 1
&lt;-recv
</pre>
</div>

<p>
多信道选择用select完成：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">for</span> {
        <span style="color: #800;">select</span> {
        <span style="color: #800;">case</span> v, ok = &lt;-a: s = <span style="color: #800;">"a"</span>
        <span style="color: #800;">case</span> v, ok = &lt;-b: s = <span style="color: #800;">"b"</span>
        }
        <span style="color: #800;">if</span> ok {
                fmt.<span style="color: #048; font-weight: bold;">Println</span>(s, v)
        } <span style="color: #800;">else</span> {
                os.<span style="color: #048; font-weight: bold;">Exit</span>(0)
        }
}

<span style="color: #800;">for</span> i := 0; i &lt; 5; i++ {
        <span style="color: #800;">select</span> {
        <span style="color: #800;">case</span> a &lt;- i:
        <span style="color: #800;">case</span> b &lt;- i:
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18">过度并发</h4>
<div class="outline-text-4" id="text-orgheadline18">
<p>
Go语言圣经中8.6节提供第一种通过tokens的方法来避免过度并发，原理上类似semaphore，但是这种方法并不是没有缺点的，当传递给信道的列表足够大时，仍然会有过度并发问题，此时将出现大量线程竞争semaphore的情况。
</p>

<p>
比较正规的做法是建立一个工人组（线程池），他们随时等待活干。
</p>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19">睡眠定时</h4>
<div class="outline-text-4" id="text-orgheadline19">
<p>
打点器和time.Sleep()都是借助定时器实现的，其中time.Sleep()包括三步：
</p>
<ol class="org-ol">
<li>创建定时器</li>
<li>挂起当前进程</li>
<li>定时器到期时，使当前进程就绪</li>
</ol>

<p>
这些功能都由time包中提供，基本用例如下，需要注意timer.Stop()和ticker.Stop()不会关闭信道。
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">main</span>() {
        timeChan := time.<span style="color: #048; font-weight: bold;">NewTimer</span>(time.Second).C
        tickChan := time.<span style="color: #048; font-weight: bold;">NewTicker</span>(time.Millisecond * 400).C
        doneChan := <span style="color: #800;">make</span>(<span style="color: #800;">chan</span> <span style="color: #800;">bool</span>)
        <span style="color: #800;">go</span> <span style="color: #800;">func</span>() {
                time.<span style="color: #048; font-weight: bold;">Sleep</span>(time.Second * 2)
                doneChan &lt;- <span style="color: #800;">true</span>
        }()

        <span style="color: #800;">for</span> {
                <span style="color: #800;">select</span> {
                <span style="color: #800;">case</span> &lt;-timeChan:
                        fmt.<span style="color: #048; font-weight: bold;">Println</span>(<span style="color: #800;">"Timer expired"</span>)
                <span style="color: #800;">case</span> &lt;-tickChan:
                        fmt.<span style="color: #048; font-weight: bold;">Println</span>(<span style="color: #800;">"Ticker ticked"</span>)
                <span style="color: #800;">case</span> &lt;-doneChan:
                        fmt.<span style="color: #048; font-weight: bold;">Println</span>(<span style="color: #800;">"Done"</span>)
                        <span style="color: #800;">return</span>
                }
        }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">项目管理</h3>
<div class="outline-text-3" id="text-orgheadline24">
</div><div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">基本配置</h4>
<div class="outline-text-4" id="text-orgheadline21">
<p>
常用环境变量如下：
</p>
<dl class="org-dl">
<dt>GOROOT</dt><dd>安装位置</dd>
<dt>GOARCH</dt><dd>目标处理器架构</dd>
<dt>GOOS</dt><dd>目标主机操作系统</dd>
<dt>GOBIN</dt><dd>编译器安装位置</dd>
<dt>GOHOSTOS</dt><dd>目标机器操作系统</dd>
<dt>GOHOSTARCH</dt><dd>目标机器处理器架构</dd>
<dt>GOPATH</dt><dd>主路径</dd>
</dl>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">依赖管理</h4>
<div class="outline-text-4" id="text-orgheadline22">
<p>
每个包对应一个独立名字空间，包内的名字如果以大写字符开头那么该名字就是导出的。如果文件被声明为<code>package main</code>就是指定该文件为主程序，当一个包包含多个文件时，构建工具根据文件名排序发给编译器，编译器再逐个初始化。包文件中可以定义一个<code>init()</code>函数来指定初始化顺序。
</p>

<p>
导入包的几种写法：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">import</span>     <span style="color: #800;">"sample/test"</span>      <span style="color: #666;">// </span><span style="color: #666;">test.A</span>
<span style="color: #800;">import</span>  M  <span style="color: #800;">"sample/test"</span>      <span style="color: #666;">// </span><span style="color: #666;">M.A</span>
<span style="color: #800;">import</span>  .  <span style="color: #800;">"sample/test"</span>      <span style="color: #666;">// </span><span style="color: #666;">A</span>
<span style="color: #800;">import</span>  _  <span style="color: #800;">"sample/test"</span>      <span style="color: #666;">// </span><span style="color: #666;">&#20165;&#25191;&#34892;&#21021;&#22987;&#21270;&#20989;&#25968;</span>
</pre>
</div>

<p>
常用包：<a href="http://studygolang.com/static/pkgdoc/index.html">标准库索引</a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">报名</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/fmt.htm">fmt</a></td>
<td class="org-left">格式化输出</td>
</tr>

<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/log.htm">log</a></td>
<td class="org-left">简易日志</td>
</tr>

<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/os.htm">os</a></td>
<td class="org-left">操作系统函数和底层文件操作</td>
</tr>

<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/time.htm">time</a></td>
<td class="org-left">时间操作接口</td>
</tr>

<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/net.htm">net</a></td>
<td class="org-left">网络</td>
</tr>

<tr>
<td class="org-left"><a href="http://studygolang.com/static/pkgdoc/pkg/database_sql.htm">sql</a></td>
<td class="org-left">数据库</td>
</tr>
</tbody>
</table>


<p>
io包提供字节切片操作接口，以及少量实现，如io.Copy，
io/ioutil实现了一些辅助函数来处理文件一次性读写和输入输出任务。
os包提供了一个比较强大的File类型来支持文件读写。
bufio的核心在缓冲，io仅仅定义了接口，而bufio可以认为是对io中接口的一个很好的实现。
bytes提供的函数和对象集中在对字节切片的操作上，strings和bytes包在形式上一致，只不过strings用于字符串处理。
</p>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23">质量管理</h4>
<div class="outline-text-4" id="text-orgheadline23">
<div class="org-src-container">

<pre class="src src-sh">godoc -http=:4001                       <span style="color: #666;"># </span><span style="color: #666;">&#29983;&#25104;&#26412;&#22320;&#25991;&#26723;</span>
go vet package/path/name
go tool vet -shadow source/directory/*.go
go tool vet source/directory
</pre>
</div>
<p>
默认会使用<code>-all</code>选项，如果指定某个选项，则只检测该选项，如果禁止某个选项，则只禁止该选项。比较实用的是<code>-shadow</code>用来检测变量覆盖问题。
</p>

<p>
测试文件需要命名为：<code>[^.]*_test.go</code>。测试函数分为功能测试和性能测试：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">TestAdd1</span>(t *<span style="color: #800;">testing.T</span>)
<span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">BenchmarkAdd1</span>(t *<span style="color: #800;">testing.T</span>)
</pre>
</div>
<p>
性能测试可以在启动测试先暂停计时器：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #800;">func</span> <span style="color: #048; font-weight: bold;">BenchmarkAdd1</span>(b *<span style="color: #800;">testing.B</span>) {
        b.<span style="color: #048; font-weight: bold;">StopTimer</span>()
        <span style="color: #048; font-weight: bold;">DoPreparation</span>()
        b.<span style="color: #048; font-weight: bold;">StartTimer</span>()

        <span style="color: #800;">for</span> i := 0; i &lt; b.N; i++ {
                <span style="color: #048; font-weight: bold;">Add</span>(1, 2)
        }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-2">
<h2 id="orgheadline26">参考资料</h2>
<div class="outline-text-2" id="text-orgheadline26">
<ul class="org-ul">
<li><a href="http://studygolang.com/static/pkgdoc/index.html">标准库索引</a></li>
<li><a href="https://docs.ruanjiadeng.com/gopl-zh/index.html">Go语言圣经（中文版）</a></li>
<li><a href="http://xhrwang.me/2014/12/22/golang-fundamentals-1-types-variables-constants.html">Golang语言基础系列</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/the-way-to-go/">Go入门指南</a></li>
<li><a href="http://www.miek.nl/downloads/Go/Learning-Go-latest.pdf">Learning Go</a> | <a href="http://mikespook.com/learning-go/">中文版</a></li>
<li><a href="https://gobyexample.com/">Go by Example</a></li>
<li><a href="http://ptgmedia.pearsoncmg.com/images/9780321774637/samplepages/0321774639.pdf">Programming in Go</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang">build a web with golang</a></li>
<li><a href="https://github.com/wonderfo/wonderfogo/wiki">Go语言资料收集</a></li>
<li><a href="http://jan.newmarch.name/go/all.pdf">Network programming with Go</a></li>
</ul>
</div>
</div>
